<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Practical Pedestal/Swagger: Slack integration</title>

		<meta name="description" content="How the combination of Pedestal, Swagger and other useful patterns allowed the low friction implementation of a RESTful extension for the messaging service Slack to provide Memes-as-a-Service">
		<meta name="author" content="Oliver Hine">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

    <link rel="stylesheet" href="css/slacky-pres.css">
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h2>Practical Pedestal/Swagger: Slack integration</h2>
          <img style="max-height: 250px" src="images/doge-patterns-useful.jpg"/>
          <p style="margin-top: 0;">
            <a class="slacky-link" target="_blank" href="https://slacky-server.herokuapp.com/">
              <img class="logo" src="images/slacky-icon.png"/>
              slacky-server.herokuapp.com
            </a>
            <br/>
            <a class="github" target="_blank" href="https://github.com/oliyh/slacky">
              <img class="logo" src="images/github.png"/>
              oliyh/slacky
            </a>
          </p>
					<p>
						<small>Created by <a target="_blank" href="http://oliy.co.uk">Oliver Hine</a> / <a target="_blank" href="http://twitter.com/oliyh">@oliyh</a></small>
					</p>
				</section>

				<section>
					<h2>Slack</h2>
					<p>
						A developer-friendly chat service
					</p>
          <img class="stretch" src="images/slack-chat.png"/>
          <aside class="notes">
            I will firstly introduce Slack briefly for anyone unfamiliar with it.
            Slack is a chat service which has gained popular adoption among software organisations including Clojurians and JUXT - it feels friendly for developers with markdown-like formatting.
            Images, videos and other media can be embedded directly into the chat window giving a richer experience.
            It also has a comprehensive API for third party extensions. Many already exist, for Twitter, Github etc, but one was missing...
          </aside>
				</section>
        
        <section>
					<h2>Memes!</h2>
          <p>
            <em>an idea, behavior, style, or usage that spreads from person to person within a culture</em>
          </p>
          <img src="images/simple-made-complex-meme.png"/>
          <aside class="notes">
            We as a team got quite addicted to memes via the Sassy bot in Hipchat, which had a nice simple text-based interface.
            Slack however had no such feature, so I set out to build one.
          </aside>
				</section>

        <section>
					<h2>The Slack "Slash" command</h2>
          <img src="images/slack-slash-command.png"/>
          <pre><code>  POST

  token=gIkuvaNzQIHg97ATvDxqgjtO
  team_id=T0001
  team_domain=juxt
  channel_id=C2147483705
  channel_name=general
  user_id=U2147483697
  user_name=frankie
  command=/meme
  text=rich hickey | simple | made complex</code></pre>
          <span><a target="_blank" href="https://api.slack.com/slash-commands">api.slack.com/slash-commands</a></span>
          <aside class="notes">
            Slack allows you to register a custom command beginning with a slash which will be captured and sent to an HTTP endpoint of your choice.
            The documentation tells you that the request will look like this one here.
            I wanted to implement this endpoint but I didn't want to spend time writing a webserver or implementing REST, dealing with JSON deserialisation and error handling - I just wanted to get started on writing the handler.
          </aside>
				</section>

        <section>
          <h2>pedestal-swagger</h2>
          <p>
            Deserialisation, coercion and related error handling
          </p>
          <div class="col2">
            <div style="width: 43%">
              <pre><code class="hljs" data-trim contenteditable>
  (s/defschema SlackRequest
 {(req :token)        s/Str
  (req :team_id)      s/Str
  (req :team_domain)  s/Str
  (req :channel_id)   s/Str
  (req :channel_name) s/Str
  (req :user_id)      s/Str
  (req :user_name)    s/Str
  (req :command)      s/Str
  (req :text)         s/Str})</code></pre>
            </div>
            <div style="width: 57%">
              <pre><code class="hljs" data-trim contenteditable>
(swagger/defhandler slack-meme
 {:summary "Responds asynchonously to 
            Slash commands from Slack"
  :parameters {:formData SlackRequest}
  :responses {200 {:schema MemeUrl}}}
 [{:keys [form-params] :as request}]
 
 (let [text (:text form-params)]
   {:status 200
    :body (meme/generate-meme text)))
              </code></pre>
            </div>
          </div>
          <a class="github" target="_blank" href="https://github.com/frankiesardo/pedestal-swagger">
            <img class="logo" src="images/github.png"/>
            frankiesardo/pedestal-swagger
          </a>
          
          <aside class="notes">
            This is exactly what I wanted - I define a schema which describes the request I expect, and a handler which expects that schema.
            No deserialisation, no validation, I can just trust that the data will fit that schema when it hits my handler.
            Also note it's nicely documented in the code.
          </aside>
        </section>
        
        <section>
          <h2>Routing and interceptors</h2>
          <pre class="stretch"><code class="hljs" data-trim contenteditable>
(swagger/defroutes api-routes
  {:info {:title "Slacky"
          :description "Memes and more for Slack"
          :externalDocs {:description "Find out more"
                         :url "https://github.com/oliyh/slacky"}
          :version "2.0"}
   :tags [{:name "meme"
           :description "All the memes!"}]}
  [[["/api" ^:interceptors [(swagger/body-params)
                            bootstrap/json-body
                            (swagger/coerce-request)
                            (swagger/validate-response)]

     ["/slack"
      ["/meme" ^:interceptors [(annotate {:tags ["meme"]})]
       {:post slack-meme}]]

     ["/swagger.json" {:get [(swagger/swagger-json)]}]
     ["/*resource" {:get [(swagger/swagger-ui)]}]]]])
          </code></pre>
            
          <aside class="notes">
            This is the routing table, with some interceptors and a couple of endpoints provided by pedestal-swagger.
            These will take care of deserialising, validating and coercing requests for me and ensuring my handler can stay simple and only worry about the happy path.
          </aside>
        </section>

        <section>
					<h2>Swagger UI</h2>
          <img class="stretch no-border" src="images/swagger-ui.png"/>
          <aside class="notes">
            The necessary data for the Swagger UI is generated for us by pedestal-swagger, giving us the super-useful Swagger UI for free!
          </aside>
				</section>
        
        <section>
          <section data-transition="none">
            <h2>Meme generation</h2>
            <img class="stretch no-border" src="images/meme-handling-1.png"/>
            <aside class="notes">
              We parse the text into parts and then use the search term to find an appropriate template image on google
            </aside>
          </section>
          <section data-transition="none">
            <h2>Meme generation</h2>
            <img class="stretch no-border" src="images/meme-handling-2.png"/>
            <aside class="notes">
              We send the url of the template to MemeCaptain which returns us a template id
            </aside>
          </section>
          <section data-transition="none">
            <h2>Meme generation</h2>
            <img class="stretch no-border" src="images/meme-handling-3.png"/>
            <aside class="notes">
              We ask MemeCaptain to generate a meme based on the template id and the upper and lower text
              MemeCaptain returns a url to the generated meme image
              It's complicated enough!
            </aside>
          </section>
        </section>
        
        <section>
					<h2>Responding to Slack</h2>
					<img class="stretch no-border" src="images/authentication-requirement.png"/>
          <span><a target="_blank" href="https://api.slack.com/incoming-webhooks">api.slack.com/incoming-webhooks</a></span>
          <aside class="notes">
            To write back in to Slack requires an incoming webhook URL unique to the team.
            To support multiple teams we register the token supplied in the slash command post against an incoming webhook url.
            When the slash command comes in, we simply lookup the webhook url and use it to write the meme back into the Slack channel it came from.
          </aside>
				</section>
        
        <section>
          <h2>Authentication interceptor</h2>
          <pre class="stretch"><code class="hljs" data-trim contenteditable>
(swagger/defbefore authenticate-slack-call
  {:description "Ensures caller has registered an incoming webhook"
   :parameters {:formData {:token s/Str}}
   :responses {403 {}}}
  [{:keys [request response] :as context}]

  (let [db (:db-connection request)
        token (get-in request [:form-params :token])
        account (accounts/lookup-slack-account db token)]
    (if-let [webhook-url (:key account)]
      (update context :request merge {::slack-webhook-url webhook-url
                                      ::account-id (:id account)})
      (-> (terminate context)
          (assoc :response
            {:status 403
             :headers {}
             :body (str "You are not permitted to use this service.\n"
                        "Please register your token '" token
                        "'at https://slacky-server.herokuapp.com")})))))
            </code></pre>
          <aside class="notes">
            Here I create an interceptor that deals completely with all the authentication requirements.
            It doesn't pollute my handler, it can either decide it's authenticated and provide the webhook url to the handler,
            or it's not authenticated and we return a 403 and an error message.
            
            It all gets merged into the Swagger definition too so clients know that a 403 might be returned.
          </aside>
				</section>

        <section>
					<h2>Self-migrating database</h2>
					<p>
            Ensure database is migrated before use
					</p>
          <pre><code class="hljs" data-trim contenteditable>
(defn- migrate-db [url]
    (joplin/migrate-db
     {:db {:type :jdbc :url url}
      :migrator "migrators/jdbc"}))
      
(defn create-db-connection [url]
  (migrate-db url)

  (condp re-find url
    #":postgresql:" (pool "org.postgresql.Driver" url))
    #":h2:" (pool "org.h2.Driver" url))</code></pre>
          <a class="github" href="https://github.com/juxt/joplin">
            <img class="logo" src="images/github.png"/>
            juxt/joplin
          </a>
          <aside class="notes">
            Production deployments become easier, no danger of running code that is incompatible with database
            Joplin takes care of ensuring the migrations are applied
            Database migrations compatible with both postgres (production) and H2 (tests)
          </aside>
				</section>

        <section>
					<h2>Angel interceptor</h2>
					<p>
						Decomplect interceptor scope from ordering
					</p>
          <pre><code class="hljs" data-trim contenteditable>
(defroutes routes
  ["/api" ^:interceptors [rate-limiter]
    ["/slack" ^:interceptors [slack-auth] ...]
    ["/hipchat" ^:interceptors [hipchat-auth] ...]])</code></pre>
          <a class="github" href="https://github.com/oliyh/angel-interceptor">
            <img class="logo" src="images/github.png"/>
            oliyh/angel-interceptor
          </a>
          <aside class="notes">
            Consider extending Slacky to another chat service, Hipchat - we add another endpoint with a hipchat-auth interceptor
            Consider also wanting to limit the rate at which each account can access the API, and adding a general purpose interceptor on the API root
            In this instance, the rate limiter will need an account id to determine whether to allow the request or not, but it runs before the
            authorisation interceptors which provide the account id.
            This is normal pedestal behaviour but it complects the scope of the interceptor with the order.
          </aside>
				</section>

        <section>
					<h2>Angel interceptor</h2>
          <pre><code class="hljs" data-trim contenteditable>
(require '[angel.interceptor :as angel])

(defroutes routes
  ["/api" ^:interceptors [(angel/requires rate-limiter :account)]
    ["/slack" ^:interceptors 
              [(angel/provides slack-auth :account)] ...]
    ["/hipchat" ^:interceptors 
                [(angel/provides hipchat-auth :account)] ...]])</code></pre>
          <pre class="fragment"><code class="hljs" data-trim contenteditable>
(def service
  (angel/satisfy
    {:io.pedestal.http/routes routes}))</code></pre>
          <a class="github" href="https://github.com/oliyh/angel-interceptor">
            <img class="logo" src="images/github.png"/>
            oliyh/angel-interceptor
          </a>
          <aside class="notes">
            Here we declare the relationship between the interceptors and then simply run the "satisfy" function over the pedestal service map
            This will reorder the interceptors for each route without affecting their scope, so that the rate-limiter will always have an account-id to work with
            This is a new library you can get on Github, it does just enough at the moment for this use case but you may find it useful
          </aside>
				</section>

        <section>
					<h2>Slacky</h2>
					<!-- <img class="stretch no-border" src="images/slacky-logo.png"/> -->
          <video id="demo-video" class="stretch" controls>
            <source data-src="video/slacky-demo.mp4" type="video/mp4">
          </video> 
          <br/>
          <a class="slacky-link" target="_blank" href="https://slacky-server.herokuapp.com/">
            <img class="logo" src="images/slacky-icon.png"/>
            slacky-server.herokuapp.com
          </a>
          <aside class="notes">
            The end result is a simple service with self contained functions
            Simple deployment to Heroku makes it available for the world to use
            (Click link and show them the front page)
          </aside>
				</section>
        
        <section>
					<h2>Slacky</h2>
					<video class="stretch" controls>
            <source src="video/epic-memes.mp4" type="video/mp4">
          </video> 
          <br/>
          <a class="slacky-link" target="_blank" href="https://slacky-server.herokuapp.com/">
            <img class="logo" src="images/slacky-icon.png"/>
            slacky-server.herokuapp.com
          </a>
          <aside class="notes">
            Other features: animated memes, register templates (time for this?)
          </aside>
				</section>
        
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
